\chapter{Dezvoltarea soluției}\label{ch:4dezvoltareaSolutiei}

	Acest capitol conține o prezentarea detaliată a modului în care a fost implementat proiectul. Voi face referiri atât la partea harware, cât și la partea software. 

\section{Specificarea cerințelor}
	...

\section{Arhitectura sistemului}

\begin{figure}[H]
   	\centering
    	\includegraphics[width=1\textwidth]{ArhitecturaSistemului.jpg}
	\caption{Arhitectura sistemului}
\end{figure}

	Sistemul a fost conceput pentru un apartament cu două camere, însă poate fi extins pentru un număr mai mare de încăperi. La nivel macro, este format din trei module, câte un modul senzor pentru fiecare cameră și un modul de control, montat în apropierea centralei termice.

	Modulul senzor prezintă o complexitate mai mare, este alcătuit din mai multe componente și îndeplinește o serie de funcționalități. Preia informații precum: temperatura și umiditatea și le trimite în baza de date. În continuare, aceste valori sunt afișate utilizând aplicația web, făcând posibilă monitorizarea parametrilor ambientali. De asemenea, are acces la temperatura setată, iar in funcție de aceasta și de temperatura curentă din cameră controlează electrovalva și trimite comandă de oprire sau pornire a centralei. Un alt rol esențial pe care îl îndeplinește modulul, este de a face posibilă setarea unei valori a temperaturii ce urmează să fie menținută în cameră.

	Modulul de control este de o complexitate redusă. Primește comenzi de la modulele senzor, iar în funcție de acestea controlează centrala. Modulul se folosește de logică de tip "SAU", dacă cel puțin un modul senzor trimite comandă de pornire, atunci centrala termică trebuie să înceapă ciclul de încălzire.

	Transferul de date între modulele senzor și modulul de control se face prin intermediul undelor radio, 433 MHz. Placuțele ESP8266 se folosesc de unde Wi-Fi, 2.4 GHz, pentru a se conecta la router.

\subsection{Modulul senzor}

\begin{figure}[H]
   	\centering
    	\includegraphics[width=1\textwidth]{ModulSenzor.png}
	\caption{Arhitectura modulului senzor}
\end{figure}	

	Este format din următoarele componente:
	\begin{itemize}
		\setlength{\itemindent}{2em}
			\itemsep0em
			\item Modul WiFi NodeMCU
			\item Placă de bază pentru NodeMCU
			\item LCD
			\item Senzor de temperatură și umiditate
			\item Releu
			\item Butoane
			\item Transmițător RF
			\item Electrovalvă
			\item Invertor de semnal
			\item Rezistență
			\item Condensator
			\item Alimentator 12 volți
	\end{itemize}

	Componenta principală din acest ansamblu este modulul wireless. Se conectează prin WiFi la un punct de acces al rețelei, router-ul în cazul proiectului prezentat, și face transfer de date cu baza de date utilizată. Acesta pune la dispoziție o serie de pini pentru a putea conecta diverse componente auxiliare. 
	
	Pinul D0 este utilizat pentru a conecta pinul de date de la senzorul de temperatură și umiditate.

	Pinii D1 și D2 se conectează la pinii SCL și SDA pentru a face posibil transferul de date prin protocolul de comunicație $I^2C$.

	Pinul D3 se conectează la pinul IN al releului și are rolul de a controla închiderea sau deschiderea releului, iar pinii D5 și D6 sunt rezervați pentru butoane. 

	Pinul D7 transferă date la pinul de date al transmițătorului RF. 

\vspace{1em}

	Placa de bază pentru modulul WiFi are două roluri esențiale în crearea circuitului. Acesta facilitează felul în care se poate alimenta plăcuța wireless, punând la dispoziție o mufă de alimentare care poate fi conectată la alimentatoare ce furnizează tensiuni între 6 și 24 de volți. Prin intermediul unui regulator de tensiune va aduce tensiunea de alimentare a modulului WiFi până la 5 volți, prevenind orice posibilitate de supraalimentare. Astfel, placa de bază pune la dispoziție pini ce oferă tensiuni de ieșire de 3.3 volti, 5 volți și o serie de pini ce sunt conectați direct la mufa de alimentare și furnizează voltaj egal cu cel dat de alimentator. De asemenea, oferă pentru fiecare pin al modulului ESP8266 încă 4 pini corespondenți, fapt ce reprezintă un avantaj când vine vorba de conectarea unor componente auxiliare.

\vspace{1em}

	Pentru a putea afișa temperatura curentă din cameră și temperatura setată, se folosește un display. Transferul de date între LCD și modulul WiFi, la care este conectat, se face prin intermediul protocolului de comunicație $I^2C$. S-a ales acest protocol deoarece reduce considerabil numărul de fire necesare pentru conectarea și alimentarea LCD-ului, în acest caz fiind necesare doar 4. Prin urmare, display-ul pune la dispoziție următorii pini:  VCC, GND, SDA și SCL.

\vspace{1em}

	Senzorul de temperatură și umiditate pe care îl utilizez prezintă 3 pini. Doi sunt utilizati pentru alimentare, VCCC și GND, iar cel de-al treilea este pinul de date, utilizat pentru transferul de informații între senzor și plăcuța cu microcontroler la care este conectat.

\vspace{1em}

	Releul este conectat la modulul wireless și este controlat de acesta prin pinul IN. Rolul releului este de întrerupător în circuitul electric format din electrovalvă și alimentator.

\vspace{1em}

	Sunt prezente două butoane ce permit modificarea temperaturii setate. Butonul de sus incrementează temperatura și se conectează la pinul D5 al modului WiFi, iar butonul de jos decrementează valoarea temperaturii și se conectează la pinul D6.

\vspace{1em}

	Transmițătorul RF prezintă 3 pini: VCC, GND și DATA. Pinii VCC și GND se conectează la o sursă de tensiune, ieșirile de 12 volți oferite de placa de bază NodeMCU. Pinul de date se conectează la pinul digital D7 al modulului wireless și face posibil transferul de date între acestea. În continuare, datele vor fi transferate la receptorul de tip RF, montat pe modulul de control.  

\vspace{1em}

	Electrovlava se montează pe returul caloriferelor și este responsabilă cu închiderea sau deschiderea circuitului de apă din calorifer. Releul este cel care întrerupe, sau nu, alimentarea electrică a electrovalvei.

\vspace{1em}

	Invertorul de semnal, rezistența și condensatorul sunt componente electrice pe care le-am utilizat pentru a filtra semnalul provenit de la buton.  

\subsection{Modulul de control}

\begin{figure}[H]
   	\centering
    	\includegraphics[width=1\textwidth]{ModululDeControl.png}
	\caption{Arhitectura modulului de control}
\end{figure}

	Acesta nu prezintă conexiune la internet. Modulul wireless este înlocuit cu o plăcuță Arduino Uno, care se ocupă de partea de procesare a datelor primite de la modulele din camere. Prezintă o serie de intrări și ieșiri analogice, dar si digitale. 

	Pinul digital 4 se conectează la pinul de date al receptorului, făcând posibil transferul de informații între acestea.
	
	Pinul digital 7 se conectează la pinul IN al releului și transmite comanda de închidere sau deschidere a acestuia.

\vspace{1em}

	Releul se alimentează la o tensiune de 5 volți, tensiune provenită de la Arduino. În momentul în care releul este pe poziție închis, centrala termică va porni.

\vspace{1em}

	Receptorul, asemenea releului, se alimentează cu 5 volti de la plăcuța Arduino și are rolul de a prelua datele de la transmițătoarele din camere.

\section{Proiectare detaliată}

	...

\section{Implementarea soluției}

	În acest subcapitol voi prezenta secvențe de cod folosite pentru programarea părții hardware, dar și cod aferent aplicației web.

\subsection{Programare modul ESP8266}

\subsubsection{Inițializări}

	Modulul prezintă o serie vastă de funcționalități și se conectează cu mai multe componente auxiliare. Pentru programarea acestuia am utilizat ArduinoIDE, iar ca și limbaj de programare C++. 

	Codul este împărțit în trei fișiere cu estensii diferite: .ino, .cpp și .h. În fișierul cu extensia .h se află prototipurile claselor și al metodelor, iar fișierul .cpp conține implementările acestor metode. Fișierul .ino este alcătuit din două funcții: \textit{setup} și \textit{loop}. Prima este utilizată pentru inițializări și se execută o singură dată, la pornirea modulului. În ceea ce privește cea de-a doua funcție, se execută în mod repetitiv până la oprirea alimentării plăcuței WiFi.

\vspace{1em}

	În continuare, voi prezenta funcția \textit{setup} din fișierul .ino și voi explica rolul apelurilor din cadrul acesteia.

\vspace{2em}

\begin{lstlisting}
#include "WiFiModule.h"

WiFiModule wifiModule;
LCD lcd;
TimeManager timeManager;
RFTransmitter rfTransmitter;
DHTSensor dhtSensor;

FirebaseData streamDesiredTemperature;
FirebaseData streamSwitchIntervalsOn;
FirebaseData streamIntervals;


void setup() {
    timeManager.timeManagerConfig();
    lcd.initializeLCD();
    rfTransmitter.initializeRFTransmitter();
    wifiModule.pinSetup();
    wifiModule.connectToInternet("Asus", "vitomir10");
    Firebase.begin(FIREBASE_HOST, FIREBASE_AUTH);
    wifiModule.defineInterrupts();
    wifiModule.stream(streamDesiredTemperature, "/DesiredTempRoom2/Zapier/Value");
    wifiModule.stream(streamSwitchIntervalsOn, "/SwitchIntervalsOn/Value");  
    wifiModule.stream(streamIntervals, "/Intervals");
    delay(500);
}
\end{lstlisting}

\vspace{2em}

	Pentru început, se creează instanțe pentru clasele ale căror funcționalități urmează să fie utilizate, iar în corpul funcției \textit{setup} se vor apela funcții ce țin de inițializare.

	Din clasa \textit{TimeManager} se apelează metoda \textit{timeManagerConfig}, fiind responsabilă de setarea fusului orar pentru a ști în mod exact data și timpul curent. Acestea sunt necesare în modul de funcționare automat, mod în care se ține cont de temperaturile setate de utilizator pe anumite intervale orare. 

	Până se execută toate funcțiile de inițializare, LCD-ul va fi pornit și va afișa mesajul \textit{"Initializing..."}. Pentru ca acest comportament să fie posibil, este necesar apelul metodei \textit{lcd.initializeLCD()}. 	

	Apelarea metodei \textit{initializeRFTransmitter} din cadrul clasei \textit{RFTransmitter} are ca și scop declanșarea procesului de inițializare al transmițătorului. Acesta reprezintă o precondiție pentru transferul de date între modulele senzor și modulul de control.

	Pinii disponibili pe această componentă electronică pot funcționa fie ca intrări, fie ca ieșiri, insă este responsabilitatea programatorului să seteze modul de funcționare a fiecărui pin în parte. Toate aceste configurații le-am grupat în metoda \textit{pinSetup}, al cărei cod îl voi face disponibil.

\vspace{1em}

\begin{lstlisting}
void WiFiModule::pinSetup(){
     pinMode(RELAY_PIN, OUTPUT);
     pinMode(INCREASE_TEMPERATURE_PIN, INPUT);
     pinMode(DECREASE_TEMPERATURE_PIN, INPUT);
     pinMode(LED_BUILTIN, OUTPUT);
}
\end{lstlisting}

\vspace{2em}	

	Pentru identificarea pinilor am definit macrouri, cu nume sugestive, iar cuvintele cheie \textit{INPUT} și \textit{OUTPUT} au fost predefinite în bibliotecile utilizate.

	Majoritatea funcționalităților îndeplinite de acest modul necesită o conexiune validă la internet. Primul pas în acest sens se face prin apelul metodei \textit{connectToInternet}. În cadrul funcției \textit{WiFi.begin()} trebuie menționat numele rețelei la care se conectează și parola. Modulul este programat în așa fel încât timpul alocat conectării la internet să fie de maximum 15 secunde. Dacă acesta este depășit, este posibil să fie o problemă în ceea ce privește conexiunea la internet, iar modulul va funcționa deconectat de la baza de date.
 
	După ce plăcuța WiFi a reușit să se conecteze la internet, următorul pas este identificarea bazei de date. Apelul metodei \textit{Firebase.begin} necesită doi parametri, și anume: adresa bazei de date și cheia secretă. Aceștia sunt utilizați pentru a localiza baza de date, respectiv pentru a oferi acces la aceasta.

	Setarea temperaturii se realizează prin întreruperi. Trebuie definit pinul și frontul semnalului pe care se declanșează întreruperea, dar și numele rutinei de tratare. Toate acestea se realizează în metoda \textit{defineInterrupts}.

	Ultimele apeluri din funcția \textit{setup}, \textit{stream(instance, path)}, au rolul de a seta instanța și câmpul din baza de date pentru care se vor monitoriza schimbările de valoare. Modulul face citiri din baza de date doar când sunt date actualizate, astfel reușind să economisească din resursele disponibile.

\subsubsection{Întreruperile și tratarea acestora}

	În continuare, voi prezenta rutinele de tratare a întreruperilor. Acestea sunt simple, nu consumă multe resurse și, ceea ce este esențial în crearea unor astfel de rutine, execuția lor nu durează mult. De asemenea, utilizez două variabile globale, \textit{increaseDesiredTemperature} și \textit{decreaseDesiredTemperature}, pentru a marca faptul că o procedura de tratare a întreruperii a fost accesată.

\vspace{1em}

\begin{lstlisting}
ICACHE_RAM_ATTR void increaseTemperature() {
    increaseDesiredTemperature = true;
}

ICACHE_RAM_ATTR void decreaseTemperature() {
    decreaseDesiredTemperature = true;
}  
\end{lstlisting}

\vspace{2em}	

	În momentul în care este acționat unul din cele două butoane responsabile cu modificarea temperaturii setate, se declansează execuția unei serii de instrucțiuni. Acestea sunt consumatoare de resurse, motiv pentru care, se execută în interiorul funcției \textit{loop}. 


\vspace{1em}

\begin{lstlisting}
 if(increaseDesiredTemperature || decreaseDesiredTemperature){
    if(increaseDesiredTemperature){
      if(desiredTemperature < MAX_TEMP){
          desiredTemperature++;
          lcd.displayDesiredTemperature();
          if (WiFi.status() == WL_CONNECTED && (!switchIntervalsOn))
          {
              wifiModule.sendDesiredTemperatureToDatabase ("DesiredTempRoom2/Zapier/Value");
          }
      }
      increaseDesiredTemperature = false;
    }else{
        if(desiredTemperature > MIN_TEMP){
          desiredTemperature--;
          lcd.displayDesiredTemperature();
          if (WiFi.status() == WL_CONNECTED && (!switchIntervalsOn))
          {
              wifiModule.sendDesiredTemperatureToDatabase ("DesiredTempRoom2/Zapier/Value");
          }
        }
      decreaseDesiredTemperature = false;
    }
  }
\end{lstlisting}

\vspace{2em}	

	Pentru început, se verifică dacă de la ultima iterație a fost modificată variabila \textit{increaseDesiredTemperature} sau \textit{decreaseDesiredTemperature}. În caz afirmativ, se face o incrementare sau decrementare a valorii temperaturii setate. Pentru ca rezultatul să se afișeze pe LCD cât mai repede, după ajustarea valorii, se face apelul funcției \textit{displayDesiredTemperature}, din cadrul clasei LCD. Astfel, se obține un timp mic de actualizare și o experiență mai bună cu utilizatorul. De asemenea, se examinează modul de funcționare a modulului wireless, conectat sau deconectat la o rețea de internet. In cazul în care există o conexiune validă, valoarea actualizată a temperaturii va fi trimisă în baza de date. O altă condiție necesară ca modul de funcționare pe intervale orare să fie dezactivat  \textit{!switchIntervalsOn}.

\subsubsection{Mod de operare presetat de utilizator}

	Sistemul este setat asfel încât să ofere posibilitatea utilizatorului de a alege patru intervale orare, cu temperaturi diferite, în timpul zilelor lucrătoare. În ceea ce privește ultimele zile ale săptămânii, sâmbătă și duminică, se pot seta doar două intervale orare pe zi, cu temperaturi diferite.


\vspace{1em}

\begin{lstlisting}
if (WiFi.status() == WL_CONNECTED) {
   wifiModule.sendCurrentTemperatureToDatabase(currentTemperature);
   wifiModule.sendHumidityToDatabase(humidity);
   wifiModule.readStreamValue(switchIntervalsOn, streamSwitchIntervalsOn, "SwitchIntervalsOn/Value");
   if (switchIntervalsOn) {
        int weekDay = timeManager.getWeekDay();
        int currentHour = timeManager.getCurrentHour();
        int currentMinute = timeManager.getCurrentMinute();
        if(wifiModule.checkForUpdate(streamIntervals, "/Intervals") || (!timeIntervalsOperatingMode))
        {
         if (weekDay == 6 || weekDay == 0) {
             String A = wifiModule.readStr("Intervals/Weekend/A");
             String B = wifiModule.readStr("Intervals/Weekend/B");

             int hourA = timeManager.getHourFromTimeFormat(A);
             int minuteA = timeManager.getMinuteFromTimeFormat(A);
             int hourB = timeManager.getHourFromTimeFormat(B);
             int minuteB = timeManager.getMinuteFromTimeFormat(B);

             if ((hourA < currentHour && currentHour < hourB) ||
                 (hourA == currentHour && currentMinute >= minuteA) ||
                 (hourB == currentHour && currentMinute < minuteB)) {
                   wifiModule.readDesiredTemperatureFromDatabase ("Intervals/Weekend/TemperatureAB");
                   endHour = hourB;
                   endMinute = minuteB;
             } else {
                 wifiModule.readDesiredTemperatureFromDatabase ("Intervals/Weekend/TemperatureBA");
                 endHour = hourA;
                 endMinute = minuteA;       
   }
} 
\end{lstlisting}

\vspace{2em}	

	Primele două instrucțiuni au rolul de a încărca în baza de date valoarea temperaturii si a umiditătii. Modul de funcționare a sistemului este salvat într-un câmp al bazei de date, numit \textit{SwitchIntervalsOn/Value}. Acesta este monitorizat prin instalarea unui observator pe câmpul bazei de date. 

	Instrucțiunile ce urmează au rolul de a încadra sistemul în ora, minutul și ziua curentă, iar cu ajutorul acestora, sistemul poate urmări programul de temperaturi setat de către utilizator. Secvența de cod prezentată anterior este utilizată pentru încadrarea zilelor de la sfârșitul săptămânii, sâmbătă si duminică. In cazul în care nu se respectă condițita, se execută secvențele condiționale următoare, împreună cu citirile capetelor intervalelor și valorile temperaturilor corespunzătoare.

\vspace{1em}
	
\begin{lstlisting}
 {
                String A = wifiModule.readStr("Intervals/WorkingDay/A");
                String B = wifiModule.readStr("Intervals/WorkingDay/B");
                String C = wifiModule.readStr("Intervals/WorkingDay/C");
                String D = wifiModule.readStr("Intervals/WorkingDay/D");

                int hourA = timeManager.getHourFromTimeFormat(A);
                int minuteA = timeManager.getMinuteFromTimeFormat(A);
                int hourB = timeManager.getHourFromTimeFormat(B);
                int minuteB = timeManager.getMinuteFromTimeFormat(B);
                int hourC = timeManager.getHourFromTimeFormat(C);
                int minuteC = timeManager.getMinuteFromTimeFormat(C);
                int hourD = timeManager.getHourFromTimeFormat(D);
                int minuteD = timeManager.getMinuteFromTimeFormat(D);


                if ((hourA < currentHour && currentHour < hourB) || 
                     (hourA == hourB && currentHour == hourA && currentMinute >= minuteA && currentMinute < minuteB)||
                    (hourA == currentHour && hourB != currentHour && currentMinute >= minuteA) ||
                    (hourA != currentHour && hourB == currentHour && currentMinute < minuteB)) {
                        wifiModule.readDesiredTemperatureFromDatabase
									("Intervals/WorkingDay/TemperatureAB");
                        endHour = hourB;
                        endMinute = minuteB;
                } else if ((hourB < currentHour && currentHour < hourC) || 
                     (hourB == hourC && currentHour == hourB && currentMinute >= minuteB && currentMinute < minuteC)||
                    (hourB == currentHour && hourC != currentHour && currentMinute >= minuteB) ||
                    (hourB != currentHour && hourC == currentHour && currentMinute < minuteC)){
                              wifiModule.readDesiredTemperatureFromDatabase
									("Intervals/WorkingDay/TemperatureBC");
                              endHour = hourC;
                              endMinute = minuteC;
                } else if ((hourC < currentHour && currentHour < hourD) || 
                     (hourC == hourD && currentHour == hourC && currentMinute >= minuteC && currentMinute < minuteD)||
                    (hourC == currentHour && hourD != currentHour && currentMinute >= minuteC) ||
                    (hourC != currentHour && hourD == currentHour && currentMinute < minuteD)) {
                              wifiModule.readDesiredTemperatureFromDatabase
									("Intervals/WorkingDay/TemperatureCD");
                              endHour = hourD;
                              endMinute = minuteD;
                } else {
                    wifiModule.readDesiredTemperatureFromDatabase
									("Intervals/WorkingDay/TemperatureDA");
                    endHour = hourA;
                    endMinute = minuteA;
                }
            }
\end{lstlisting}
\vspace{2em}

\subsubsection{Mod clasic de operare}

	Pe lângă modul automat de funcționare, sistemul este proiectat să poată rula și în mod manual. Acesta presupune menținerea unei temperaturi constante, setate de utilizator, prin butoane, comenzi vocale sau prin intermediul aplicației web. Este important de menționat faptul că acesta consumă mai puține resurse comparativ cu modul de funcționare pe intervale, însă nu oferă același grad de confort. În continuare, voi prezenta o serie de instrucțiuni de cod specifice implementării modului manual.

\vspace{1em}
\begin{lstlisting}
int currentTemperature = dhtSensor.readTemp();
int humidity = dhtSensor.readHumidity();
\end{lstlisting}
\vspace{2em}	

	Prima etapă ce se execută în acest mod este citirea umidității și a temperaturii de la senzorul DHT11. Iar funcțiile responsabile pentru aceste funcționalități sunt apelate la începutul funcției \textit{loop}.

\vspace{1em}
\begin{lstlisting}
     wifiModule.heatControl(currentTemperature); 
     wifiModule.statusIndicator();
     lcd.displayDesiredTemperature();
     lcd.displayCurrentTemperature(currentTemperature);
\end{lstlisting}
\vspace{2em}	

	Pentru a face posibilă conectarea/deconectarea sistemului de încălzire, este necesar apelul funcției \textit{heatControl}. Acesta trimite comandă atât la electrovalva montată pe calorifer, cât și la centrala termică. De asemenea, este necesar apelul \textit{displayDesiredTemperature} și \textit{displayCurrentTemperature} pentru a afișa temperatura setată și temperatura dorită din cameră. Scopul final este de a permite monitorizarea temperaturii ambientale.

\subsection{Programare plăcuță Arduino}

	Este montată în modulul de control și se conectează la componente auxiliare precum: receptor RF și releu, iar prin intermediul acestora face posibil controlul centralei termice. Codul sursă care face posibil tot acest comportament se află pe plăcuța Arduino. 

\vspace{1em}
	
\begin{lstlisting}
unsigned char dataPackage[3];
uint8_t dataPackageLength = sizeof(dataPackage);
if (driver.recv(dataPackage, &dataPackageLength))
{
    dataPackage[2] = '\0';
    Serial.println((char *) dataPackage);
    int dataPackageInt = atoi((char *) dataPackage);

    if((dataPackageInt/10) == 1){
           commandModule1 = dataPackageInt%10;
           timeFirstModuleSent = millis()/1000;
    }
     else{
            commandModule2 = dataPackageInt%10;
            timeSecondModuleSent = millis()/1000;
        }
        
        Serial.print("Module1:");
        Serial.println(commandModule1);
        Serial.print("Module2:");
        Serial.println(commandModule2);
        if(commandModule1 || commandModule2){
          digitalWrite(7, LOW);
          Serial.println("On");
        }else{
          digitalWrite(7, HIGH);
          Serial.println("Off");
        }
  }
  if((((millis()/1000) - timeFirstModuleSent) >= TIMEOUT && ((millis()/1000) - timeSecondModuleSent) >= TIMEOUT))
  {
          digitalWrite(7, HIGH);
          commandModule1 = 0;
          commandModule2 = 0;
   }
   else if(((millis()/1000) - timeFirstModuleSent) >= TIMEOUT && commandModule2 == 0)
   {
          digitalWrite(7, HIGH);
          commandModule1 = 0;
    }
    else if(((millis()/1000) - timeSecondModuleSent) >= TIMEOUT && commandModule1 == 0) {
          digitalWrite(7, HIGH);
          commandModule2 = 0;
}
\end{lstlisting}
\vspace{2em} 

	Mesajul pe care modulul receptor îl interceptează este format din doi octeți, din care octetul cel mai semnificativ conține numărul de identificare al modulului, iar octetul cel mai puțin semnificativ deține informații legate de natura comenzii. Mesajul recepționat este convertit în întreg, datorită faptului că se poate prelucra mai ușor, aplicând operații precum: modulo și div.

	Întotdeauna se salvează momentul în care s-au recepționat informații de la fiecare modul în parte. Este importantă menținerea evidenței pentru a evita situațiile în care apar întreruperi de transfer prin radio - frecvență. Ca și o măsură de prevenție, dacă modulul de control nu primește comenzi de la modulele senzor timp mai mare sau egal cu 5 secunde, centrala termică va fi oprită.

	După ce au fost primite comenzi de la ambele module senzor, se execută operație logică de tip SAU, iar în funcție de rezultatul acesteia, va cupla sau decupla releul, ce in continuare controlează centrala termică. Un octet cu valoarea 1 indică pornirea, iar un octet cu valoarea 0 indică oprirea centralei din imobil. De asemenea, ultimele instrucțiuni condiționale din secvența de cod afișată anterior, au rolul de a implementa oprirea de siguranță a sistemului de încălzire. 

	Inițial, se verifică dacă ambele module senzor nu au trimis comenzi de mai mult de 5 secunde. Dacă nu se respectă prima condiție, se examinează cazul în care primul modul are conexiunea întreruptă, iar cel de-al doilea trimite comandă de oprire a sistemului de încălzire. Iar ultima situație care poate apărea este cea în care conexiunea prin radio frecvență la al doilea modul este inactivă de peste 5 secunde, iar primul modul trimite comandă de întrerupere a funcționării centralei. Toate aceste situații apar în cazuri de avarie, iar principala cauză este comunicația precară între modulele senzor și modulul de control. Pentru a preveni defectarea centralei termice, este concepută o măsură de siguranță ce constă în oprirea acesteia.  

\subsection{Realizarea aplicației web}

	Aplicația web face transferul de date cu partea electronică prin intermediul bazei de date \textit{Firebase}. Citirile valorilor umidității și a temperaturii se actualizează în aplicația web doar atunci când apar modificări in baza de date. Astfel, se evită citirile repetate și consumatoare de resurse.
	
	În ceea ce privește partea de acces a aplicației, aceasta este găzduită pe un server, la distanță, prin intermediul platformei \textit{Keroku}. Oricine deține adresa aplicației o poate accesa, însă prima pagină care apare la accesare este cea de conectare, iar navigarea poate fi continuată doar în cazul în care utilizatorul deține un cont valid. 
	
\vspace{1em}
	Printre funcționalitățile esențiale pe care le deține aplicația sunt:

\begin{itemize}
\setlength{\itemindent}{2em}
	\itemsep0em
	\item pagina principală, ce apare imediat după o conectare cu succes, prezintă rolurile cele mai importante, si anume: posibilitatea de monitorizare a temperaturii și umidității ambientale, dar și reglarea temperaturii dorite. Este construită pentru două camere, dar poate fi extinsă pentru mai multe.
	\item pagina de programare a intervalelor orare si temperaturile corespunzătoare acestora este, de asemenea, o funcționalitate utilă pentru utilizatori și pentru partea de control al modului de funcționare al sistemului.
	\item pentru a permite accesul si altor persoane la aplicație, pagina de creare cont oferă posibilitatea de adăugare a noi intrări în baza de date. Astfel, un administrator poate oferi dreptul de acces și altor utilizatori. 
	\item un administrator are dreptul de a analiza lista persoanelor care dețin un cont și de a adăuga sau retrage anumite drepturi de acces.
	\item o funcționalitate utilă pentru persoanele care primesc conturile cu credențialele setate de către un administrator, este posibilitatea de schimbare a parolei vechi. Astfel, parolele rămân confidențiale fiecărui utilizator în parte.
\end{itemize}
	
\subsubsection{Secvențe de cod esențiale din cadrul implementării aplicației web}

	Prin intermediul paginii \textit{home} din cadrul aplicației web, utilizatorul are posibilitatea să salveze în baza de date diverse valori ale temperaturilor ce urmează a fi menținute în imobil. În continuare, voi prezenta funcția care se apelează în această situație. Este implementată în \textit{flask} și se execută în momentul în care se ajunge la calea \textit{/home}. 

\vspace{1em}
\begin{lstlisting}
@app.route('/home', methods=['POST', 'GET'])
@login_required
def home():
    status = firebase.get('SwitchIntervalsOn', 'Value')
    if request.method == 'POST':
        variable = request.form.get('outputValue1')
        if variable is not None:
            firebase.put('DesiredTempRoom1/Zapier', 'Value', int(variable))
        else:
            variable = request.form.get('outputValue2')
            firebase.put('DesiredTempRoom2/Zapier', 'Value', int(variable))
    return render_template('controlPage.html', status=status)
\end{lstlisting}
\vspace{2em} 


	 Se utilizează la setarea temperaturii în baza de date, dar și la citirea câmpului \textit{SwitchInvtervalsOn/Value}, ce conține informații referitoare la modul de programare al temperaturilor dorite. 

	Reprezintă o legătură între partea de interfață și logica din spatele aplicației web. Cu alte cuvinte, valoarea introdusă de către utilizator prin intermediul elementelor de intrare din \textit{html}, este transferată în partea responsabilă cu procesarea informațiilor. Prin intermediul funcțiilor puse la dispoziție de un modul implementat în \textit{python}, valorile introduse se transmit mai departe în baza de date.

	Apelul \textit{\texttt{render\_template}} este util pentru a prelucra paginile \textit{html}. Acestea pot conține diverse variabile trimise ca si parametri și pot executa structuri de control, toate acestea pentru a facilita felul în care se construiește interfața cu utilizatorul. Variabila \textit{status} este transmisă mai departe paginii intitulate \textit{controlPage} și este utilizată pentru a seta poziția butonului ce indică modul de funcționare al sistemului.




\vspace{1em}	
\begin{lstlisting}
	
\end{lstlisting}
\vspace{2em} 	

	